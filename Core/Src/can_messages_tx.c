
/*
 * This file was autogenerated by the CGEN module of the Odyssey framework.
 * DO NOT EDIT without also reporting the edit to the Odyssey-Definitions repository to be incorproated into the generator.
*/
#include "can_messages_tx.h"
#include <stdbool.h>

#include "u_queues.h"

#include "c_utils.h"
#include "fdcan.h"
#include "bitstream.h"


static void handle_bitstream_overflow(bitstream_t *bitstream_res,
					    uint32_t can_id);

uint8_t send_dashboard_efuse
(uint16_t ADC,float voltage,float current,bool is_faulted,bool is_enabled)
{
    can_msg_t msg;
    msg.id = 0xEF0;
    msg.id_is_extended = true;msg.len = 8;

    
    uint64_t data = 0;
    data |= ((uint16_t)(ADC) & 0xFFFFULL) << 48;
    data |= ((uint16_t)(voltage*1000) & 0xFFFFULL) << 32;
    data |= ((uint16_t)(current*1000) & 0xFFFFULL) << 16;
    data |= ((uint8_t)(is_faulted) & 0xFFULL) << 8;
    data |= ((uint8_t)(is_enabled) & 0xFFULL) << 0;

    
    uint64_t data_bigendian = __builtin_bswap64(data);
    memcpy(msg.data, &data_bigendian, 8);
    

    return queue_send(&can_outgoing, &msg, TX_NO_WAIT);
}

uint8_t send_brake_efuse
(uint16_t ADC,float voltage,float current,bool is_faulted,bool is_enabled)
{
    can_msg_t msg;
    msg.id = 0xEF1;
    msg.id_is_extended = true;msg.len = 8;

    
    uint64_t data = 0;
    data |= ((uint16_t)(ADC) & 0xFFFFULL) << 48;
    data |= ((uint16_t)(voltage*1000) & 0xFFFFULL) << 32;
    data |= ((uint16_t)(current*1000) & 0xFFFFULL) << 16;
    data |= ((uint8_t)(is_faulted) & 0xFFULL) << 8;
    data |= ((uint8_t)(is_enabled) & 0xFFULL) << 0;

    
    uint64_t data_bigendian = __builtin_bswap64(data);
    memcpy(msg.data, &data_bigendian, 8);
    

    return queue_send(&can_outgoing, &msg, TX_NO_WAIT);
}

uint8_t send_shutdown_efuse
(uint16_t ADC,float voltage,float current,bool is_faulted,bool is_enabled)
{
    can_msg_t msg;
    msg.id = 0xEF2;
    msg.id_is_extended = true;msg.len = 8;

    
    uint64_t data = 0;
    data |= ((uint16_t)(ADC) & 0xFFFFULL) << 48;
    data |= ((uint16_t)(voltage*1000) & 0xFFFFULL) << 32;
    data |= ((uint16_t)(current*1000) & 0xFFFFULL) << 16;
    data |= ((uint8_t)(is_faulted) & 0xFFULL) << 8;
    data |= ((uint8_t)(is_enabled) & 0xFFULL) << 0;

    
    uint64_t data_bigendian = __builtin_bswap64(data);
    memcpy(msg.data, &data_bigendian, 8);
    

    return queue_send(&can_outgoing, &msg, TX_NO_WAIT);
}

uint8_t send_lv_efuse
(uint16_t ADC,float voltage,float current,bool is_faulted,bool is_enabled)
{
    can_msg_t msg;
    msg.id = 0xEF3;
    msg.id_is_extended = true;msg.len = 8;

    
    uint64_t data = 0;
    data |= ((uint16_t)(ADC) & 0xFFFFULL) << 48;
    data |= ((uint16_t)(voltage*1000) & 0xFFFFULL) << 32;
    data |= ((uint16_t)(current*1000) & 0xFFFFULL) << 16;
    data |= ((uint8_t)(is_faulted) & 0xFFULL) << 8;
    data |= ((uint8_t)(is_enabled) & 0xFFULL) << 0;

    
    uint64_t data_bigendian = __builtin_bswap64(data);
    memcpy(msg.data, &data_bigendian, 8);
    

    return queue_send(&can_outgoing, &msg, TX_NO_WAIT);
}

uint8_t send_radfan_efuse
(uint16_t ADC,float voltage,float current,bool is_faulted,bool is_enabled)
{
    can_msg_t msg;
    msg.id = 0xEF4;
    msg.id_is_extended = true;msg.len = 8;

    
    uint64_t data = 0;
    data |= ((uint16_t)(ADC) & 0xFFFFULL) << 48;
    data |= ((uint16_t)(voltage*1000) & 0xFFFFULL) << 32;
    data |= ((uint16_t)(current*1000) & 0xFFFFULL) << 16;
    data |= ((uint8_t)(is_faulted) & 0xFFULL) << 8;
    data |= ((uint8_t)(is_enabled) & 0xFFULL) << 0;

    
    uint64_t data_bigendian = __builtin_bswap64(data);
    memcpy(msg.data, &data_bigendian, 8);
    

    return queue_send(&can_outgoing, &msg, TX_NO_WAIT);
}

uint8_t send_fanbatt_efuse
(uint16_t ADC,float voltage,float current,bool is_faulted,bool is_enabled)
{
    can_msg_t msg;
    msg.id = 0xEF5;
    msg.id_is_extended = true;msg.len = 8;

    
    uint64_t data = 0;
    data |= ((uint16_t)(ADC) & 0xFFFFULL) << 48;
    data |= ((uint16_t)(voltage*1000) & 0xFFFFULL) << 32;
    data |= ((uint16_t)(current*1000) & 0xFFFFULL) << 16;
    data |= ((uint8_t)(is_faulted) & 0xFFULL) << 8;
    data |= ((uint8_t)(is_enabled) & 0xFFULL) << 0;

    
    uint64_t data_bigendian = __builtin_bswap64(data);
    memcpy(msg.data, &data_bigendian, 8);
    

    return queue_send(&can_outgoing, &msg, TX_NO_WAIT);
}

uint8_t send_pumpone_efuse
(uint16_t ADC,float voltage,float current,bool is_faulted,bool is_enabled)
{
    can_msg_t msg;
    msg.id = 0xEF6;
    msg.id_is_extended = true;msg.len = 8;

    
    uint64_t data = 0;
    data |= ((uint16_t)(ADC) & 0xFFFFULL) << 48;
    data |= ((uint16_t)(voltage*1000) & 0xFFFFULL) << 32;
    data |= ((uint16_t)(current*1000) & 0xFFFFULL) << 16;
    data |= ((uint8_t)(is_faulted) & 0xFFULL) << 8;
    data |= ((uint8_t)(is_enabled) & 0xFFULL) << 0;

    
    uint64_t data_bigendian = __builtin_bswap64(data);
    memcpy(msg.data, &data_bigendian, 8);
    

    return queue_send(&can_outgoing, &msg, TX_NO_WAIT);
}

uint8_t send_pumptwo_efuse
(uint16_t ADC,float voltage,float current,bool is_faulted,bool is_enabled)
{
    can_msg_t msg;
    msg.id = 0xEF7;
    msg.id_is_extended = true;msg.len = 8;

    
    uint64_t data = 0;
    data |= ((uint16_t)(ADC) & 0xFFFFULL) << 48;
    data |= ((uint16_t)(voltage*1000) & 0xFFFFULL) << 32;
    data |= ((uint16_t)(current*1000) & 0xFFFFULL) << 16;
    data |= ((uint8_t)(is_faulted) & 0xFFULL) << 8;
    data |= ((uint8_t)(is_enabled) & 0xFFULL) << 0;

    
    uint64_t data_bigendian = __builtin_bswap64(data);
    memcpy(msg.data, &data_bigendian, 8);
    

    return queue_send(&can_outgoing, &msg, TX_NO_WAIT);
}

uint8_t send_battbox_efuse
(uint16_t ADC,float voltage,float current,bool is_faulted,bool is_enabled)
{
    can_msg_t msg;
    msg.id = 0xEF8;
    msg.id_is_extended = true;msg.len = 8;

    
    uint64_t data = 0;
    data |= ((uint16_t)(ADC) & 0xFFFFULL) << 48;
    data |= ((uint16_t)(voltage*1000) & 0xFFFFULL) << 32;
    data |= ((uint16_t)(current*1000) & 0xFFFFULL) << 16;
    data |= ((uint8_t)(is_faulted) & 0xFFULL) << 8;
    data |= ((uint8_t)(is_enabled) & 0xFFULL) << 0;

    
    uint64_t data_bigendian = __builtin_bswap64(data);
    memcpy(msg.data, &data_bigendian, 8);
    

    return queue_send(&can_outgoing, &msg, TX_NO_WAIT);
}

uint8_t send_mc_efuse
(uint16_t ADC,float voltage,float current,bool is_faulted,bool is_enabled)
{
    can_msg_t msg;
    msg.id = 0xEF9;
    msg.id_is_extended = true;msg.len = 8;

    
    uint64_t data = 0;
    data |= ((uint16_t)(ADC) & 0xFFFFULL) << 48;
    data |= ((uint16_t)(voltage*1000) & 0xFFFFULL) << 32;
    data |= ((uint16_t)(current*1000) & 0xFFFFULL) << 16;
    data |= ((uint8_t)(is_faulted) & 0xFFULL) << 8;
    data |= ((uint8_t)(is_enabled) & 0xFFULL) << 0;

    
    uint64_t data_bigendian = __builtin_bswap64(data);
    memcpy(msg.data, &data_bigendian, 8);
    

    return queue_send(&can_outgoing, &msg, TX_NO_WAIT);
}

uint8_t send_shutdown_pins
(bool bms_gpio,bool bots_gpio,bool spare_gpio,bool bspd_gpio,bool hv_c,bool hvd_gpio,bool imd_gpio,bool ckpt_gpio,bool inertia_sw_gpio,bool tsms_gpio,uint8_t UNUSED)
{
    can_msg_t msg;
    msg.id = 0x123;
    msg.id_is_extended = false;
    msg.len = 2;

    
    uint16_t data = 0;
    data |= ((uint8_t)(bms_gpio) & 0x1ULL) << 15;
    data |= ((uint8_t)(bots_gpio) & 0x1ULL) << 14;
    data |= ((uint8_t)(spare_gpio) & 0x1ULL) << 13;
    data |= ((uint8_t)(bspd_gpio) & 0x1ULL) << 12;
    data |= ((uint8_t)(hv_c) & 0x1ULL) << 11;
    data |= ((uint8_t)(hvd_gpio) & 0x1ULL) << 10;
    data |= ((uint8_t)(imd_gpio) & 0x1ULL) << 9;
    data |= ((uint8_t)(ckpt_gpio) & 0x1ULL) << 8;
    data |= ((uint8_t)(inertia_sw_gpio) & 0x1ULL) << 7;
    data |= ((uint8_t)(tsms_gpio) & 0x1ULL) << 6;
    data |= ((uint8_t)(UNUSED) & 0x3FULL) << 0;

    
    uint16_t data_bigendian = __builtin_bswap16(data);
    memcpy(msg.data, &data_bigendian, 2);
    

    return queue_send(&can_outgoing, &msg, TX_NO_WAIT);
}

uint8_t send_car_state
(bool home_mode,uint8_t nero_index,int32_t car_speed,bool tsms,uint32_t torque_limit_percentage,bool reverse,uint16_t regen_limit,bool launch_control)
{
    can_msg_t msg;
    msg.id = 0x501;
    msg.id_is_extended = false;
    msg.len = 6;

    
    uint64_t data = 0;
    data |= ((uint8_t)(home_mode) & 0xFULL) << 44;
    data |= ((uint8_t)(nero_index) & 0xFULL) << 40;
    data |= ((uint16_t)(int16_t)(car_speed*10) & 0xFFFFULL) << 24;
    data |= ((uint8_t)(tsms) & 0x1ULL) << 23;
    data |= ((uint8_t)(torque_limit_percentage*100) & 0x7FULL) << 16;
    data |= ((uint8_t)(reverse) & 0x1ULL) << 15;
    data |= ((uint16_t)(regen_limit) & 0x3FFULL) << 5;
    data |= ((uint8_t)(launch_control) & 0x1ULL) << 4;

    
    uint64_t data_bigendian = __builtin_bswap64(data);
    memcpy(msg.data, &data_bigendian, 8);
    

    return queue_send(&can_outgoing, &msg, TX_NO_WAIT);
}

uint8_t send_pedal_percent_pressed_values
(float accel_norm,float brake_norm)
{
    can_msg_t msg;
    msg.id = 0x505;
    msg.id_is_extended = false;
    msg.len = 4;

    
    uint32_t data = 0;
    data |= ((uint16_t)(accel_norm*100) & 0xFFFFULL) << 16;
    data |= ((uint16_t)(brake_norm*100) & 0xFFFFULL) << 0;

    
    uint32_t data_bigendian = __builtin_bswap32(data);
    memcpy(msg.data, &data_bigendian, 4);
    

    return queue_send(&can_outgoing, &msg, TX_NO_WAIT);
}

uint8_t send_pedal_sensor_voltages
(float accel1_volts,float accel2_volts,float brake1_volts,float brake2_volts)
{
    can_msg_t msg;
    msg.id = 0x504;
    msg.id_is_extended = false;
    msg.len = 8;

    
    uint64_t data = 0;
    data |= ((uint16_t)(accel1_volts*100) & 0xFFFFULL) << 48;
    data |= ((uint16_t)(accel2_volts*100) & 0xFFFFULL) << 32;
    data |= ((uint16_t)(brake1_volts*100) & 0xFFFFULL) << 16;
    data |= ((uint16_t)(brake2_volts*100) & 0xFFFFULL) << 0;

    
    uint64_t data_bigendian = __builtin_bswap64(data);
    memcpy(msg.data, &data_bigendian, 8);
    

    return queue_send(&can_outgoing, &msg, TX_NO_WAIT);
}

uint8_t send_lightning_board_light_status
(uint8_t status)
{
    can_msg_t msg;
    msg.id = 0xCA;
    msg.id_is_extended = false;
    msg.len = 1;

    
    uint8_t data = 0;
    data |= ((uint8_t)(status) & 0x3ULL) << 6;

    
    msg.data[0] = data;
    

    return queue_send(&can_outgoing, &msg, TX_NO_WAIT);
}

uint8_t send_temperature_sensor
(float vcu_temperature,float vcu_humidity)
{
    can_msg_t msg;
    msg.id = 0x508;
    msg.id_is_extended = false;
    msg.len = 4;

    
    uint32_t data = 0;
    data |= ((uint16_t)(int16_t)(vcu_temperature*100) & 0xFFFFULL) << 16;
    data |= ((uint16_t)(vcu_humidity*100) & 0xFFFFULL) << 0;

    
    uint32_t data_bigendian = __builtin_bswap32(data);
    memcpy(msg.data, &data_bigendian, 4);
    

    return queue_send(&can_outgoing, &msg, TX_NO_WAIT);
}

uint8_t send_imu_accelerometer
(float imu_accelerometer_x,float imu_accelerometer_y,float imu_accelerometer_z)
{
    can_msg_t msg;
    msg.id = 0x506;
    msg.id_is_extended = false;
    msg.len = 6;

    
    uint64_t data = 0;
    data |= ((uint16_t)(int16_t)(imu_accelerometer_x*100) & 0xFFFFULL) << 32;
    data |= ((uint16_t)(int16_t)(imu_accelerometer_y*100) & 0xFFFFULL) << 16;
    data |= ((uint16_t)(int16_t)(imu_accelerometer_z*100) & 0xFFFFULL) << 0;

    
    uint64_t data_bigendian = __builtin_bswap64(data);
    memcpy(msg.data, &data_bigendian, 8);
    

    return queue_send(&can_outgoing, &msg, TX_NO_WAIT);
}

uint8_t send_imu_gyro
(float imu_gyro_x,float imu_gyro_y,float imu_gyro_z)
{
    can_msg_t msg;
    msg.id = 0x507;
    msg.id_is_extended = false;
    msg.len = 6;

    
    uint64_t data = 0;
    data |= ((uint16_t)(int16_t)(imu_gyro_x*100) & 0xFFFFULL) << 32;
    data |= ((uint16_t)(int16_t)(imu_gyro_y*100) & 0xFFFFULL) << 16;
    data |= ((uint16_t)(int16_t)(imu_gyro_z*100) & 0xFFFFULL) << 0;

    
    uint64_t data_bigendian = __builtin_bswap64(data);
    memcpy(msg.data, &data_bigendian, 8);
    

    return queue_send(&can_outgoing, &msg, TX_NO_WAIT);
}

uint8_t send_faults
(bool CAN_OUTGOING_FAULT,bool CAN_INCOMING_FAULT,bool BMS_CAN_MONITOR_FAULT,bool ONBOARD_TEMP_FAULT,bool IMU_ACCEL_FAULT,bool IMU_GYRO_FAULT,bool BSPD_PREFAULT,bool ONBOARD_BRAKE_OPEN_CIRCUIT_FAULT,bool ONBOARD_ACCEL_OPEN_CIRCUIT_FAULT,bool ONBOARD_BRAKE_SHORT_CIRCUIT_FAULT,bool ONBOARD_ACCEL_SHORT_CIRCUIT_FAULT,bool ONBOARD_PEDAL_DIFFERENCE_FAULT,bool RTDS_FAULT,int EXTRA)
{
    can_msg_t msg;
    msg.id = 0x502;
    msg.id_is_extended = false;
    msg.len = 2;

    
    uint16_t data = 0;
    data |= ((uint8_t)(CAN_OUTGOING_FAULT) & 0x1ULL) << 15;
    data |= ((uint8_t)(CAN_INCOMING_FAULT) & 0x1ULL) << 14;
    data |= ((uint8_t)(BMS_CAN_MONITOR_FAULT) & 0x1ULL) << 13;
    data |= ((uint8_t)(ONBOARD_TEMP_FAULT) & 0x1ULL) << 12;
    data |= ((uint8_t)(IMU_ACCEL_FAULT) & 0x1ULL) << 11;
    data |= ((uint8_t)(IMU_GYRO_FAULT) & 0x1ULL) << 10;
    data |= ((uint8_t)(BSPD_PREFAULT) & 0x1ULL) << 9;
    data |= ((uint8_t)(ONBOARD_BRAKE_OPEN_CIRCUIT_FAULT) & 0x1ULL) << 8;
    data |= ((uint8_t)(ONBOARD_ACCEL_OPEN_CIRCUIT_FAULT) & 0x1ULL) << 7;
    data |= ((uint8_t)(ONBOARD_BRAKE_SHORT_CIRCUIT_FAULT) & 0x1ULL) << 6;
    data |= ((uint8_t)(ONBOARD_ACCEL_SHORT_CIRCUIT_FAULT) & 0x1ULL) << 5;
    data |= ((uint8_t)(ONBOARD_PEDAL_DIFFERENCE_FAULT) & 0x1ULL) << 4;
    data |= ((uint8_t)(RTDS_FAULT) & 0x1ULL) << 3;
    data |= ((uint8_t)(EXTRA) & 0x7ULL) << 0;

    
    uint16_t data_bigendian = __builtin_bswap16(data);
    memcpy(msg.data, &data_bigendian, 2);
    

    return queue_send(&can_outgoing, &msg, TX_NO_WAIT);
}

uint8_t send_lv_voltage
(uint16_t ADC,float Voltage)
{
    can_msg_t msg;
    msg.id = 0x509;
    msg.id_is_extended = false;
    msg.len = 6;

    
    uint64_t data = 0;
    data |= ((uint16_t)(ADC) & 0xFFFFULL) << 32;
    data |= ((uint32_t)(Voltage*1000) & 0xFFFFFFFFULL) << 0;

    
    uint64_t data_bigendian = __builtin_bswap64(data);
    memcpy(msg.data, &data_bigendian, 8);
    

    return queue_send(&can_outgoing, &msg, TX_NO_WAIT);
}



/// @brief A helper which sends appropriate error to stdout and CAN if a bistream overflows
/// @param bitstream_res The bitstream to check for overflow
/// @param can_id The CAN ID this bistream data is intended for
/// @return 0 if success
static void handle_bitstream_overflow(bitstream_t *bitstream_res,
					    uint32_t can_id)
{
	if (!bitstream_res->overflow) {
		return;
	}

    
}